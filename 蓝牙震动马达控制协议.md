# 蓝牙震动马达控制协议（V4.0）
> 标准 LE Secure Connections + Just-Works 实现 + 自定义 OTA

---

## 1 协议目标
- 标准 BLE 安全：LESC + Just-Works
- 用户交互极简：首次 1 次系统弹窗，后续秒连
- 单包完成占空比设置
- 无应用层安全逻辑，完全依赖 BLE 协议栈

---

## 2 绑定与加密流程
| 步骤 | 动作 | 备注 |
|---|---|---|
| 1 | 玩具广播 `ADV_IND` | 含 Flag LE General Discoverable |
| 2 | 手机连接 | 任意中央设备 |
| 3 | BLE 协议栈自动触发 LESC 配对 | `slave_set_wait_security = 1` |
| 4 | 系统弹窗"是否配对 **××震动玩具**？" | Just-Works，无 PIN |
| 5 | 配对成功 → BLE 协议栈存储 LTK | 自动管理 |
| 6 | 后续再连 | 自动加密复用，**零弹窗** |

---

## 3 GATT 服务定义
| 字段 | 值 |
|---|---|
| Service UUID | `9A501A2D-594F-4E2B-B123-5F739A2D594F` |
| **Motor Control Char UUID** | `9A511A2D-594F-4E2B-B123-5F739A2D594F` |
| Property | Write-Without-Response |
| **Device Info Char UUID** | `9A521A2D-594F-4E2B-B123-5F739A2D594F` |
| Property | Write + Notify |
| **OTA Update Char UUID** | `9A531A2D-594F-4E2B-B123-5F739A2D594F` |
| Property | Write + Notify |
| Security | Encryption Required (enforced by stack) |
| MTU 需求 | 244 B (推荐，用于 OTA 数据传输) |

---

## 4 数据包格式

### 4.1 马达控制（手机 → 玩具）
**Characteristic**: `9A511A2D-594F-4E2B-B123-5F739A2D594F`  
固定 **2 B**

| 偏移 | 长度 | 名称 | 类型 | 说明 |
|---|---|---|---|---|
| 0 | 2 | `duty_cycle` | uint16 | 0-10000 → 0.00%-100.00% (little-endian) |

**极简设计**: 无命令字节，无计数器，无保留字段

### 4.2 设备信息查询（手机 → 玩具 → 手机）
**Characteristic**: `9A521A2D-594F-4E2B-B123-5F739A2D594F`  
**Property**: Write + Notify

#### 4.2.1 查询请求（手机 → 玩具）
固定 **2 B**

| 偏移 | 长度 | 名称 | 类型 | 说明 |
|---|---|---|---|---|
| 0 | 1 | `header` | 0xB0 | 协议头 |
| 1 | 1 | `command` | 0x00 | 查询命令 |

**说明**: 写入 `0xB0 0x00` 触发设备信息通知

#### 4.2.2 通知响应（玩具 → 手机）
固定 **6 B**

| 偏移 | 长度 | 名称 | 类型 | 说明 |
|---|---|---|---|---|
| 0 | 1 | `header` | 0xB0 | 协议头 |
| 1 | 1 | `cmd` | 0x00 | 响应命令 |
| 2 | 1 | `motor_count` | uint8 | 马达数量（当前固定为 1） |
| 3 | 1 | `fw_version_low` | uint8 | 固件版本低字节 |
| 4 | 1 | `fw_version_high` | uint8 | 固件版本高字节 |
| 5 | 1 | `battery_level` | uint8 | 电池电量 0-100 (%) |

**示例**:
- 固件版本 1.2 → `fw_version_high=1, fw_version_low=2`
- 电池 85% → `battery_level=85`

---

## 5 安全机制
**完全由 BLE 协议栈提供:**
- **链路加密**: AES-CCM 128-bit（自动）
- **密钥交换**: P-256 ECDH（LESC）
- **重放保护**: 链路层 Packet Counter（自动）
- **数据完整性**: AES-CCM MIC（自动）
- **密钥存储**: LTK 由协议栈管理（自动）

**应用层无需任何安全逻辑**

---

## 6 设备端处理流程（伪代码）

### 6.1 马达控制处理
```c
/* BLE 协议栈确保只有加密连接才能写入 */
void motor_control_write_callback(uint8_t *data, uint16_t len) {
    if (len != 2) return ATT_ERR_INVALID_PDU;
    
    uint16_t duty = data[0] | (data[1] << 8);
    if (duty > 10000) return ATT_ERR_VALUE_NOT_ALLOWED;
    
    set_pwm_duty(duty);
    return ATT_ERR_SUCCESS;
}
```

### 6.2 设备信息查询处理
```c
/* BLE 协议栈确保只有加密连接才能写入 */
void device_info_write_callback(uint8_t *data, uint16_t len) {
    /* 检查是否为 0xB0 0x00 命令 */
    if (len != 2 || data[0] != 0xB0 || data[1] != 0x00) {
        return ATT_ERR_VALUE_NOT_ALLOWED;
    }
    
    /* 构建响应数据 */
    uint8_t response[6];
    response[0] = 0xB0;                    // header
    response[1] = 0x00;                    // cmd
    response[2] = 0x01;                    // motor_count (1 motor)
    response[3] = FIRMWARE_VERSION_LOW;    // fw_version_low
    response[4] = FIRMWARE_VERSION_HIGH;   // fw_version_high
    response[5] = get_battery_level();     // battery_level (0-100)
    
    /* 发送通知 */
    ble_send_notification(response, 6);
    
    return ATT_ERR_SUCCESS;
}
```

**就这么简单！** 写入 `0xB0 0x00` 触发通知，无状态管理，无 Flash 操作

---

## 6.3 OTA 固件升级处理

### 6.3.1 OTA 开始
**写入**: `[0x01][size_low][size_high][size_mid][size_top]`

```c
void ota_start_handler(uint8_t *data, uint16_t len) {
    uint32_t firmware_size = data[1] | (data[2] << 8) | (data[3] << 16) | (data[4] << 24);
    
    /* 擦除 Flash */
    vm_erase(0x0, firmware_size);
    
    ota_state = OTA_RECEIVING;
    ota_offset = 0;
    
    /* 通知准备就绪 */
    send_notification(0x01, 0x00);  // READY
}
```

### 6.3.2 OTA 数据传输
**写入**: `[0x02][seq_low][seq_high][data...]`

```c
void ota_data_handler(uint8_t *data, uint16_t len) {
    uint16_t seq = data[1] | (data[2] << 8);
    uint16_t data_len = len - 3;
    
    /* 写入 Flash */
    vm_write(&data[3], data_len, ota_offset);
    ota_offset += data_len;
    
    /* 发送进度 */
    uint8_t progress = (ota_offset * 100) / ota_total_size;
    send_notification(0x02, progress);  // PROGRESS
}
```

### 6.3.3 OTA 完成
**写入**: `[0x03][crc_low][crc_high][crc_mid][crc_top]`

```c
void ota_finish_handler(uint8_t *data, uint16_t len) {
    uint32_t expected_crc = data[1] | (data[2] << 8) | (data[3] << 16) | (data[4] << 24);
    
    /* 验证 CRC */
    uint32_t calculated_crc = calculate_crc32(0x0, ota_total_size);
    
    if (calculated_crc == expected_crc) {
        send_notification(0x03, 0x00);  // SUCCESS
        os_time_dly(10);  // 等待通知发送
        cpu_reset();  // 重启应用固件
    } else {
        send_notification(0xFF, 0x09);  // ERROR: CRC mismatch
    }
}
```

### 6.3.4 OTA 通知格式
| 状态 | 通知数据 | 说明 |
|---|---|---|
| 准备就绪 | `[0x01][0x00]` | 可以开始发送数据 |
| 进度更新 | `[0x02][progress%]` | 当前进度百分比 |
| 成功 | `[0x03][0x00]` | OTA 完成，即将重启 |
| 错误 | `[0xFF][error_code]` | OTA 失败，错误码 |

### 6.3.5 错误码
| 错误码 | 说明 |
|---|---|
| 0x01 | START 包长度错误 |
| 0x02 | 固件大小无效 |
| 0x03 | 未处于接收状态 |
| 0x04 | DATA 包长度错误 |
| 0x05 | Flash 写入失败 |
| 0x06 | 未处于接收状态 |
| 0x07 | FINISH 包长度错误 |
| 0x08 | 大小不匹配 |
| 0x09 | CRC 校验失败 |
| 0xFF | 未知命令 |

---

## 7 安全声明
| 项目 | 实现 |
|---|---|
| 链路加密 | AES-CCM 128-bit（BLE 协议栈） |
| 密钥交换 | P-256 ECDH（LESC） |
| 认证方式 | Just-Works（无 MITM） |
| 重放保护 | 链路层 Packet Counter（BLE 协议栈） |
| 数据完整性 | AES-CCM MIC（BLE 协议栈） |
| 密钥存储 | LTK 由 BLE 协议栈管理 |

---

## 8 OTA 使用流程

### 8.1 App 端实现
1. 读取 `app.bin` 文件（编译生成的固件）
2. 启用 OTA 特征通知
3. 发送 START 命令（包含文件大小）
4. 等待 READY 通知
5. 分块发送数据（每包 240 字节）
6. 接收进度通知
7. 发送 FINISH 命令（包含 CRC32）
8. 等待 SUCCESS 通知
9. 设备自动重启

### 8.2 固件文件
- **文件**: `SDK/cpu/bd19/tools/app.bin`
- **格式**: 原始二进制（无加密）
- **大小**: 通常 < 80KB
- **CRC**: 标准 CRC32 算法

---

## 9 发布 checklist
- [ ] 固件配置 `slave_set_wait_security = 1`（强制加密）
- [ ] 固件配置 `authentication_req_flags = SM_AUTHREQ_BONDING | SM_AUTHREQ_SECURE_CONNECTION`
- [ ] 固件配置 `io_capabilities = IO_CAPABILITY_NO_INPUT_NO_OUTPUT`
- [ ] 量产时开启芯片 RDP / APPROTECT
- [ ] App 端扫描过滤 Service UUID `9A501A2D-594F-4E2B-B123-5F739A2D594F`
- [ ] OTA 测试：使用 nRF Connect 或自定义 App 测试固件升级
